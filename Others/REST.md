Rest(**RE**presentational **S**tate **T**ransfe)表述性状态转移，是一种分布式超媒体系统的架构风格，最初由Roy Fielding在2000年的[论文中提出。

Rest在架构方面提出了一系列约束，满足这些约束的接口，称之为**RESTful**。

现在通过基于HTTP的REST服务示例理解REST。

#### REST的约束

1. **使用C/S模型**。客户端和服务器通过一个统一的接口通讯。

   > 在基于HTTP协议的Web服务中，这个约束很容易实现

2. **层次化**。每个组件都不能“看到”超出与它们交互的直接层，客户端并不会固定地与一个服务器打交道。

   > 在HTTP下，这个约束也可以容易实现。

3. **无状态**。从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。因此，会话状态完全保留在客户端上。这有利于做集群的拓展，如果每个服务端都存储上下文信息，则这些信息的同步将是很大的难题。

   > 在基于HTTP的Web服务中，一般使用Cookie和Session存储客户端或服务端的信息，要想在服务端完全不利用session存储客户信息（如：登录信息）是很难做到的。要实现这个约束，要求客户端每次的请求都附带验证信息，且服务端每次接收请求都要验证客户，在验证算法日渐复杂的今天，这样的举措无疑会给服务端带来很大的负担，这是不现实的。所以在实践中，一般在轻微违反该原则或者用更麻烦的方式中选择。

4. **可缓存**。REST系统需要能够恰当地缓存请求，以尽量减少服务端和客户端之间的信息传输，以提高性能。

   > 在HTTP下，同样容易实现。如：客户端请求一个自上次请求后没有发生过变化的信息时，如产品分类列表，服务端仅仅需要返回一个304响应即可。

5. **统一接口**。一个REST系统需要使用一个统一的接口来完成子系统之间以及服务与用户之间的交互。这使得REST系统中的各个子系统可以独自完成演化。这个约束有四个子约束：

   - **每个资源都拥有一个资源标识**。每个资源的资源标识可以用来唯一地标明该资源。
   - **消息的自描述性**。在REST系统中所传递的消息需要能够提供自身如何被处理的足够信息。例如该消息所使用的MIME类型，是否可以被缓存等。
   - **资源的自描述性**。一个REST系统所返回的资源需要能够描述自身，并提供足够的用于操作该资源的信息，如如何对资源进行添加，删除以及修改等操作。也就是说，一个典型的REST服务不需要额外的文档对如何操作资源进行说明。
   - **HATEOAS**。即客户只可以通过服务端所返回各结果中所包含的信息来得到下一步操作所需要的信息，如到底是向哪个URL发送请求等。也就是说，一个典型的REST服务不需要额外的文档标示通过哪些URL访问特定类型的资源，而是通过服务端返回的响应来标示到底能在该资源上执行什么样的操作。一个REST服务的客户端也不需要知道任何有关哪里有什么样的资源这种信息。

6. **按需编码（可选）**。 REST允许通过以小程序或脚本的形式下载和执行代码来扩展客户端功能。这通过减少预先实现所需的功能数量来简化客户端。



#### 资源

在REST的必须的五个约束中，如上述，前四种基于HTTP都可以自然而然地实现，所以现在中重点分析**统一接口**这个约束，统一接口这个约束地子约束涉及到了资源的概念，所以下面详细说明**资源**。

在REST中，主数据表示称为**资源**。

一个**资源可以是一个单或集合**。例如，“ `customers`”是集合资源，“ `customer`”是单例资源（在银行业务域中）。我们可以`customers`使用URI“ `/customers`” 来识别“ ”集合资源。我们可以`customer`使用URI“ `/customers/{customerId}`” 识别单个“ ”资源。

一个**资源可能包含子集的资源**也。例如，可以使用URN“ ”（在银行业务域中）识别`accounts`特定“ `customer`”的子集合资源“ ” `/customers/{customerId}/accounts`。类似地，`account`子集合资源“ ”内的单个资源“ ” `accounts`可以如下标识：“ `/customers/{customerId}/accounts/{accountId}`”。

以下基于HTTP理解：

参见一个例子

这是一个向服务器请求的资源，它表示商品的食品分类

```xml
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: xxx

{
   "url" : "/api/categories/1",           #该资源的标识
   "label" : "Food",                      #类别的名字
   "items_url" : "/api/items?category=1", #一个标识，标识该类别的全部商品，是该资源的子资源
   "brands" : [                           #该类别的品牌集合，也是子资源
         {  "label" : "友臣",              #品牌集合中的一个品牌，也是一个子资源，该资源的标识就是对应的url
            "brand_key" : "32073",
            "url" : "/api/brands/32073"
         }, 
         {
            "label" : "乐事",
            "brand_key" : "56632",
            "url" : "/api/brands/56632"
         }
         ...    ],
   "hot_searches" : …
}
```



**每个资源都拥有一个资源标识**，在基于HTTP地REST中，用URL来标识资源

关于资源地命名，可以参见文档：

REST资源命名指南 | RESTful API 中文网 ([p2hp.com](http://restful.p2hp.com/home/resource-naming))

**消息的自描述性**

如上，响应头中描述了消息如何被解析等信息，得到该信息，接受方就可以自己处理信息，对应于消息的自描述性这一约束。

**资源的自描述性**

在上面的响应消息中，响应体是一个资源，这个资源包含了自身包括其子资源的很多信息，包括标识符，名字，这些都明确地说明了资源表达的含义，这对应了资源的自描述性。

**HATEOAS**

在上面的资源中，资源包括资源本身的每个子资源都包含了url，这可以时资源接受方在接受到这个资源，而且仅仅依靠资格资源的信息完成跳转操作，而不需要查文档等其他操作。



#### 参考：

[](https://www.cnblogs.com/loveis715/p/4669091.html)

[](http://restful.p2hp.com/)